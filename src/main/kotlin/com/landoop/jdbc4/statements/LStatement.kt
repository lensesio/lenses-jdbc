package com.landoop.jdbc4.statements

import com.landoop.jdbc4.RowResultSet
import com.landoop.jdbc4.StreamingRowResultSet
import com.landoop.jdbc4.client.RestClient
import com.landoop.jdbc4.client.domain.StreamingSelectResult
import java.sql.Connection
import java.sql.ResultSet
import java.sql.SQLFeatureNotSupportedException
import java.util.concurrent.TimeUnit

open class LStatement(private val conn: Connection,
                      private val client: RestClient) : DefaultStatement,
    AutoCloseable,
    IWrapperStatement,
    OfflineStatement {

  // the last resultset retrieved by this statement
  private var rs: ResultSet = RowResultSet.empty()

  /**
   * Executes the given SQL statement, which returns a single
   * [ResultSet] object.
   *
   * @param sql an SQL statement to be sent to the database, typically a
   *        static SQL SELECT statement
   * @return a [ResultSet] object that contains the data produced
   *         by the given query; never null
   */
  override fun executeQuery(sql: String): ResultSet {
    TODO()
  }

  /**
   *  @return true if the first result is a [ResultSet]
   *         object; false if it is an update count or there are
   *         no results
   */
  override fun execute(sql: String): Boolean {
    return if (sql.toUpperCase().trim().startsWith("INSERT")) {
      insert(sql)
      true
    } else {
      // in this execute method we must block until we are completed
      // or we receive a record, otherwise we don't know if we can return true or false
      val result = select(sql)
      rs = StreamingRowResultSet(this, result)
      result.hasData(1, TimeUnit.DAYS)
    }
  }

  private fun insert(sql: String): Boolean {
    val withSetKey = """SET _ktype='STRING'; $sql"""
    client.insert(withSetKey)
    return true
  }

  private fun select(sql: String): StreamingSelectResult {
    val result = client.select(sql)
    rs = StreamingRowResultSet(this, result)
    return result
  }

  override fun getConnection(): Connection = conn

  override fun getResultSet(): ResultSet = rs

  override fun getQueryTimeout(): Int = client.connectionRequestTimeout()
  override fun setQueryTimeout(seconds: Int) = throw UnsupportedOperationException()

  // == the following are methods that update and thus are not supported by this read only jdbc interface ==

  override fun execute(sql: String?,
                       autoGeneratedKeys: Int): Boolean = throw SQLFeatureNotSupportedException("Auto generated keys are not supported by Lenses")

  override fun execute(sql: String?,
                       columnIndexes: IntArray?): Boolean = throw SQLFeatureNotSupportedException("Auto generated keys are not supported by Lenses")

  override fun execute(sql: String?,
                       columnNames: Array<out String>?): Boolean = throw SQLFeatureNotSupportedException("Auto generated keys are not supported by Lenses")

  override fun executeBatch(): IntArray = throw SQLFeatureNotSupportedException()
  override fun addBatch(sql: String?) = throw SQLFeatureNotSupportedException()
  override fun getGeneratedKeys(): ResultSet = throw SQLFeatureNotSupportedException()
  override fun clearBatch(): Unit = throw SQLFeatureNotSupportedException()
  override fun executeUpdate(sql: String?): Int = throw SQLFeatureNotSupportedException()
  override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int = throw SQLFeatureNotSupportedException()
  override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int = throw SQLFeatureNotSupportedException()
  override fun executeUpdate(sql: String?,
                             columnNames: Array<out String>?): Int = throw SQLFeatureNotSupportedException()

  override fun setPoolable(poolable: Boolean) = throw SQLFeatureNotSupportedException()

  override fun getUpdateCount(): Int = -1
  override fun cancel() = throw SQLFeatureNotSupportedException()

}